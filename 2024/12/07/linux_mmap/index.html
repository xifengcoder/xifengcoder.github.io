<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=-apple-system:300,300italic,400,400italic,700,700italic%7CBlinkMacSystemFont:300,300italic,400,400italic,700,700italic%7C"Apple+Color+Emoji":300,300italic,400,400italic,700,700italic%7C"Segoe+UI+Emoji":300,300italic,400,400italic,700,700italic%7C"Segoe+UI+Symbol":300,300italic,400,400italic,700,700italic%7C"Segoe+UI":300,300italic,400,400italic,700,700italic%7C"PingFang+SC":300,300italic,400,400italic,700,700italic%7C"Hiragino+Sans+GB":300,300italic,400,400italic,700,700italic%7C"Microsoft+YaHei":300,300italic,400,400italic,700,700italic%7C"Helvetica+Neue":300,300italic,400,400italic,700,700italic%7CHelvetica:300,300italic,400,400italic,700,700italic%7CArial:300,300italic,400,400italic,700,700italic%7Csans-serif:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"xifengcoder.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":true,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="OverviewLinux中的mmap进行memory mapping的过程，总的来说可以分为三个阶段：  用户进程启动映射过程，并在进程的虚拟地址空间中为映射创建虚拟映射区域；  进程在用户空间调用mmap()函数，在当前进程的虚拟地址空间中，寻找一段空闲的、满足要求的、连续的虚拟地址区域，为此虚拟地址区域分配一个vm_area_struct结构，并对之初始化，然后将该vma结构体插入到进程虚拟">
<meta property="og:type" content="article">
<meta property="og:title" content="linux mmap的理解">
<meta property="og:url" content="https://xifengcoder.github.io/2024/12/07/linux_mmap/index.html">
<meta property="og:site_name" content="Thinking in code">
<meta property="og:description" content="OverviewLinux中的mmap进行memory mapping的过程，总的来说可以分为三个阶段：  用户进程启动映射过程，并在进程的虚拟地址空间中为映射创建虚拟映射区域；  进程在用户空间调用mmap()函数，在当前进程的虚拟地址空间中，寻找一段空闲的、满足要求的、连续的虚拟地址区域，为此虚拟地址区域分配一个vm_area_struct结构，并对之初始化，然后将该vma结构体插入到进程虚拟">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-12-07T06:18:28.000Z">
<meta property="article:modified_time" content="2024-12-08T05:55:16.606Z">
<meta property="article:author" content="xifengcoder">
<meta property="article:tag" content="linux">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://xifengcoder.github.io/2024/12/07/linux_mmap/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://xifengcoder.github.io/2024/12/07/linux_mmap/","path":"2024/12/07/linux_mmap/","title":"linux mmap的理解"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>linux mmap的理解 | Thinking in code</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Thinking in code</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Overview"><span class="nav-text">Overview</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ksys-mmap-pgoff"><span class="nav-text">ksys_mmap_pgoff</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vm-mmap-pgoff"><span class="nav-text">vm_mmap_pgoff</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#do-mmap"><span class="nav-text">do_mmap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#get-unmapped-area"><span class="nav-text">get_unmapped_area</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#arch-get-unmapped-area"><span class="nav-text">arch_get_unmapped_area</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#find-vma-prev"><span class="nav-text">find_vma_prev</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#find-vma"><span class="nav-text">find_vma</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vm-unmapped-area"><span class="nav-text">vm_unmapped_area</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Data-structure"><span class="nav-text">Data structure</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#vm-area-struct"><span class="nav-text">vm_area_struct</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mm-struct"><span class="nav-text">mm_struct</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E9%A1%B5%E5%BC%82%E5%B8%B8%E4%BF%A1%E6%81%AF%EF%BC%9Avm-fault"><span class="nav-text">缺页异常信息：vm_fault</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Page-Fault"><span class="nav-text">Page Fault</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#handle-pte-fault"><span class="nav-text">handle_pte_fault</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#do-fault"><span class="nav-text">do_fault</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#do-cow-fault"><span class="nav-text">do_cow_fault</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#do-fault-1"><span class="nav-text">__do_fault</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#shmem-fault"><span class="nav-text">shmem_fault</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#filemap-fault"><span class="nav-text">filemap_fault</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#do-anonymous-page"><span class="nav-text">do_anonymous_page</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#alloc-zeroed-user-highpage-movable"><span class="nav-text">alloc_zeroed_user_highpage_movable</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#alloc-page-vma"><span class="nav-text">alloc_page_vma</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#alloc-pages-nodemask"><span class="nav-text">__alloc_pages_nodemask</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">xifengcoder</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">52</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/xifengcoder" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xifengcoder" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/xifengcoder" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xifengcoder.github.io/2024/12/07/linux_mmap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xifengcoder">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Thinking in code">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          linux mmap的理解
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-12-07 14:18:28" itemprop="dateCreated datePublished" datetime="2024-12-07T14:18:28+08:00">2024-12-07</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2024-12-08 13:55:16" itemprop="dateModified" datetime="2024-12-08T13:55:16+08:00">2024-12-08</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>40k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>37 分钟</span>
    </span>
</div>
		
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>Linux中的mmap进行memory mapping的过程，总的来说可以分为三个阶段：</p>
<ol>
<li><p>用户进程启动映射过程，并在进程的虚拟地址空间中为映射创建虚拟映射区域；</p>
<p> 进程在用户空间调用mmap()函数，在当前进程的虚拟地址空间中，寻找一段空闲的、满足要求的、连续的虚拟地址区域，为此虚拟地址区域分配一个vm_area_struct结构，并对之初始化，然后将该vma结构体插入到进程虚拟地址中的vma链表（mm_struct </p>
<p> -&gt; mmap）或红黑树（mm_struct -&gt; mm_rb）中；</p>
</li>
<li><p>调用内核空间的系统调用mmap()函数，如果是文件映射，内核将建立进程虚拟地址空间和Page Cache的映射关系；如果是匿名映射，</p>
</li>
<li><p>一旦进程开始访问映射的虚拟地址空间的某个地址，会发现并没有对应的物理页，就会触发缺页中断，这时才开始分配物理内存。</p>
</li>
</ol>
<p>本文代码所使用的Linux版本为v5.9.16</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[arch/arm64/kernel/sys.c]</span></span><br><span class="line">SYSCALL_DEFINE6(mmap, <span class="keyword">unsigned</span> <span class="keyword">long</span>, addr, <span class="keyword">unsigned</span> <span class="keyword">long</span>, len,</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span>, prot, <span class="keyword">unsigned</span> <span class="keyword">long</span>, flags,</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span>, fd, <span class="keyword">unsigned</span> <span class="keyword">long</span>, off)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (offset_in_page(off) != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ksys_mmap_pgoff(addr, len, prot, flags, fd, off &gt;&gt; PAGE_SHIFT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ksys-mmap-pgoff"><a href="#ksys-mmap-pgoff" class="headerlink" title="ksys_mmap_pgoff"></a>ksys_mmap_pgoff</h4><ul>
<li>判断类型是否为匿名映射，如果不是则为文件映射，调用fget()获取文件描述符；</li>
<li>如果是匿名映射，判断是否为大页，如果是则进行对齐处理并调用hugetlb_file_setup()获取文件描述符；</li>
<li>调用vm_mmap_pgoff()函数找寻可以映射的区域并建立映射。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[mm/mmap.c]</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">ksys_mmap_pgoff</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> len,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="keyword">unsigned</span> <span class="keyword">long</span> prot, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="keyword">unsigned</span> <span class="keyword">long</span> fd, <span class="keyword">unsigned</span> <span class="keyword">long</span> pgoff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> retval;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; MAP_ANONYMOUS)) &#123;</span><br><span class="line">        audit_mmap_fd(fd, flags);</span><br><span class="line">        file = fget(fd);</span><br><span class="line">        <span class="keyword">if</span> (!file)</span><br><span class="line">            <span class="keyword">return</span> -EBADF;</span><br><span class="line">        <span class="keyword">if</span> (is_file_hugepages(file)) &#123;</span><br><span class="line">            len = ALIGN(len, huge_page_size(hstate_file(file)));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (unlikely(flags &amp; MAP_HUGETLB)) &#123;</span><br><span class="line">            retval = -EINVAL;</span><br><span class="line">            <span class="keyword">goto</span> out_fput;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; MAP_HUGETLB) &#123;</span><br><span class="line">        struct user_struct *user = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hstate</span> *<span class="title">hs</span>;</span></span><br><span class="line"></span><br><span class="line">        hs = hstate_sizelog((flags &gt;&gt; MAP_HUGE_SHIFT) &amp; MAP_HUGE_MASK);</span><br><span class="line">        <span class="keyword">if</span> (!hs)</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">        len = ALIGN(len, huge_page_size(hs));</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * VM_NORESERVE is used because the reservations will be</span></span><br><span class="line"><span class="comment">         * taken when vm_ops-&gt;mmap() is called</span></span><br><span class="line"><span class="comment">         * A dummy user value is used because we are not locking</span></span><br><span class="line"><span class="comment">         * memory so no accounting is necessary</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        file = hugetlb_file_setup(HUGETLB_ANON_FILE, len,</span><br><span class="line">                VM_NORESERVE,</span><br><span class="line">                &amp;user, HUGETLB_ANONHUGE_INODE,</span><br><span class="line">                (flags &gt;&gt; MAP_HUGE_SHIFT) &amp; MAP_HUGE_MASK);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(file))</span><br><span class="line">            <span class="keyword">return</span> PTR_ERR(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    flags &amp;= ~(MAP_EXECUTABLE | MAP_DENYWRITE);</span><br><span class="line"></span><br><span class="line">    retval = vm_mmap_pgoff(file, addr, len, prot, flags, pgoff);</span><br><span class="line">out_fput:</span><br><span class="line">    <span class="keyword">if</span> (file)</span><br><span class="line">        fput(file);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="vm-mmap-pgoff"><a href="#vm-mmap-pgoff" class="headerlink" title="vm_mmap_pgoff"></a>vm_mmap_pgoff</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[mm/util.c]</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">vm_mmap_pgoff</span><span class="params">(struct file *file, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len, <span class="keyword">unsigned</span> <span class="keyword">long</span> prot,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flag, <span class="keyword">unsigned</span> <span class="keyword">long</span> pgoff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> populate;</span><br><span class="line">    LIST_HEAD(uf);</span><br><span class="line"></span><br><span class="line">    ret = security_mmap_file(file, prot, flag);</span><br><span class="line">    <span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mmap_write_lock_killable(mm))</span><br><span class="line">            <span class="keyword">return</span> -EINTR;</span><br><span class="line">        ret = do_mmap(file, addr, len, prot, flag, pgoff, &amp;populate,</span><br><span class="line">                  &amp;uf);</span><br><span class="line">        mmap_write_unlock(mm);</span><br><span class="line">        userfaultfd_unmap_complete(mm, &amp;uf);</span><br><span class="line">        <span class="keyword">if</span> (populate)</span><br><span class="line">            mm_populate(ret, populate);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="do-mmap"><a href="#do-mmap" class="headerlink" title="do_mmap"></a>do_mmap</h4><p>这里get_unmapped_area()函数负责寻找可映射的区域，mmap_region()负责映射该区域。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[mm/mmap.c]</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The caller must write-lock current-&gt;mm-&gt;mmap_lock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">do_mmap</span><span class="params">(struct file *file, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">unsigned</span> <span class="keyword">long</span> len, <span class="keyword">unsigned</span> <span class="keyword">long</span> prot,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">unsigned</span> <span class="keyword">long</span> flags, <span class="keyword">unsigned</span> <span class="keyword">long</span> pgoff,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">unsigned</span> <span class="keyword">long</span> *populate, struct list_head *uf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">    <span class="keyword">vm_flags_t</span> vm_flags;</span><br><span class="line">    <span class="keyword">int</span> pkey = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    *populate = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!len)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Does the application expect PROT_READ to imply PROT_EXEC?</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * (the exception is when the underlying filesystem is noexec</span></span><br><span class="line"><span class="comment">     *  mounted, in which case we dont add PROT_EXEC.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((prot &amp; PROT_READ) &amp;&amp; (current-&gt;personality &amp; READ_IMPLIES_EXEC))</span><br><span class="line">        <span class="keyword">if</span> (!(file &amp;&amp; path_noexec(&amp;file-&gt;f_path)))</span><br><span class="line">            prot |= PROT_EXEC;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* force arch specific MAP_FIXED handling in get_unmapped_area */</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MAP_FIXED_NOREPLACE)</span><br><span class="line">        flags |= MAP_FIXED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; MAP_FIXED))</span><br><span class="line">        addr = round_hint_to_min(addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Careful about overflows.. */</span></span><br><span class="line">    len = PAGE_ALIGN(len);</span><br><span class="line">    <span class="keyword">if</span> (!len)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* offset overflow? */</span></span><br><span class="line">    <span class="keyword">if</span> ((pgoff + (len &gt;&gt; PAGE_SHIFT)) &lt; pgoff)</span><br><span class="line">        <span class="keyword">return</span> -EOVERFLOW;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Too many mappings? */</span></span><br><span class="line">    <span class="keyword">if</span> (mm-&gt;map_count &gt; sysctl_max_map_count)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Obtain the address to map to. we verify (or select) it and ensure</span></span><br><span class="line"><span class="comment">     * that it represents a valid section of the address space.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    addr = get_unmapped_area(file, addr, len, pgoff, flags);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR_VALUE(addr))</span><br><span class="line">        <span class="keyword">return</span> addr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MAP_FIXED_NOREPLACE) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span> =</span> find_vma(mm, addr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (vma &amp;&amp; vma-&gt;vm_start &lt; addr + len)</span><br><span class="line">            <span class="keyword">return</span> -EEXIST;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prot == PROT_EXEC) &#123;</span><br><span class="line">        pkey = execute_only_pkey(mm);</span><br><span class="line">        <span class="keyword">if</span> (pkey &lt; <span class="number">0</span>)</span><br><span class="line">            pkey = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Do simple checking here so the lower-level routines won&#x27;t have</span></span><br><span class="line"><span class="comment">     * to. we assume access permissions have been handled by the open</span></span><br><span class="line"><span class="comment">     * of the memory object, so we don&#x27;t do any here.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    vm_flags = calc_vm_prot_bits(prot, pkey) | calc_vm_flag_bits(flags) |</span><br><span class="line">            mm-&gt;def_flags | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MAP_LOCKED)</span><br><span class="line">        <span class="keyword">if</span> (!can_do_mlock())</span><br><span class="line">            <span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mlock_future_check(mm, vm_flags, len))</span><br><span class="line">        <span class="keyword">return</span> -EAGAIN;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> file_inode(file);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> flags_mask;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!file_mmap_ok(file, inode, pgoff, len))</span><br><span class="line">            <span class="keyword">return</span> -EOVERFLOW;</span><br><span class="line"></span><br><span class="line">        flags_mask = LEGACY_MAP_MASK | file-&gt;f_op-&gt;mmap_supported_flags;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (flags &amp; MAP_TYPE) &#123;</span><br><span class="line">        <span class="keyword">case</span> MAP_SHARED:</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Force use of MAP_SHARED_VALIDATE with non-legacy</span></span><br><span class="line"><span class="comment">             * flags. E.g. MAP_SYNC is dangerous to use with</span></span><br><span class="line"><span class="comment">             * MAP_SHARED as you don&#x27;t know which consistency model</span></span><br><span class="line"><span class="comment">             * you will get. We silently ignore unsupported flags</span></span><br><span class="line"><span class="comment">             * with MAP_SHARED to preserve backward compatibility.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            flags &amp;= LEGACY_MAP_MASK;</span><br><span class="line">            fallthrough;</span><br><span class="line">        <span class="keyword">case</span> MAP_SHARED_VALIDATE:</span><br><span class="line">            <span class="keyword">if</span> (flags &amp; ~flags_mask)</span><br><span class="line">                <span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">            <span class="keyword">if</span> (prot &amp; PROT_WRITE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!(file-&gt;f_mode &amp; FMODE_WRITE))</span><br><span class="line">                    <span class="keyword">return</span> -EACCES;</span><br><span class="line">                <span class="keyword">if</span> (IS_SWAPFILE(file-&gt;f_mapping-&gt;host))</span><br><span class="line">                    <span class="keyword">return</span> -ETXTBSY;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Make sure we don&#x27;t allow writing to an append-only</span></span><br><span class="line"><span class="comment">             * file..</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (IS_APPEND(inode) &amp;&amp; (file-&gt;f_mode &amp; FMODE_WRITE))</span><br><span class="line">                <span class="keyword">return</span> -EACCES;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Make sure there are no mandatory locks on the file.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (locks_verify_locked(file))</span><br><span class="line">                <span class="keyword">return</span> -EAGAIN;</span><br><span class="line"></span><br><span class="line">            vm_flags |= VM_SHARED | VM_MAYSHARE;</span><br><span class="line">            <span class="keyword">if</span> (!(file-&gt;f_mode &amp; FMODE_WRITE))</span><br><span class="line">                vm_flags &amp;= ~(VM_MAYWRITE | VM_SHARED);</span><br><span class="line">            fallthrough;</span><br><span class="line">        <span class="keyword">case</span> MAP_PRIVATE:</span><br><span class="line">            <span class="keyword">if</span> (!(file-&gt;f_mode &amp; FMODE_READ))</span><br><span class="line">                <span class="keyword">return</span> -EACCES;</span><br><span class="line">            <span class="keyword">if</span> (path_noexec(&amp;file-&gt;f_path)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (vm_flags &amp; VM_EXEC)</span><br><span class="line">                    <span class="keyword">return</span> -EPERM;</span><br><span class="line">                vm_flags &amp;= ~VM_MAYEXEC;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!file-&gt;f_op-&gt;mmap)</span><br><span class="line">                <span class="keyword">return</span> -ENODEV;</span><br><span class="line">            <span class="keyword">if</span> (vm_flags &amp; (VM_GROWSDOWN|VM_GROWSUP))</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (flags &amp; MAP_TYPE) &#123;</span><br><span class="line">        <span class="keyword">case</span> MAP_SHARED:</span><br><span class="line">            <span class="keyword">if</span> (vm_flags &amp; (VM_GROWSDOWN|VM_GROWSUP))</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Ignore pgoff.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            pgoff = <span class="number">0</span>;</span><br><span class="line">            vm_flags |= VM_SHARED | VM_MAYSHARE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MAP_PRIVATE:</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Set pgoff according to addr for anon_vma.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            pgoff = addr &gt;&gt; PAGE_SHIFT;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Set &#x27;VM_NORESERVE&#x27; if we should not account for the</span></span><br><span class="line"><span class="comment">     * memory use of this mapping.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MAP_NORESERVE) &#123;</span><br><span class="line">        <span class="comment">/* We honor MAP_NORESERVE if allowed to overcommit */</span></span><br><span class="line">        <span class="keyword">if</span> (sysctl_overcommit_memory != OVERCOMMIT_NEVER)</span><br><span class="line">            vm_flags |= VM_NORESERVE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* hugetlb applies strict overcommit unless MAP_NORESERVE */</span></span><br><span class="line">        <span class="keyword">if</span> (file &amp;&amp; is_file_hugepages(file))</span><br><span class="line">            vm_flags |= VM_NORESERVE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addr = mmap_region(file, addr, len, vm_flags, pgoff, uf);</span><br><span class="line">    <span class="keyword">if</span> (!IS_ERR_VALUE(addr) &amp;&amp;</span><br><span class="line">        ((vm_flags &amp; VM_LOCKED) ||</span><br><span class="line">         (flags &amp; (MAP_POPULATE | MAP_NONBLOCK)) == MAP_POPULATE))</span><br><span class="line">        *populate = len;</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="get-unmapped-area"><a href="#get-unmapped-area" class="headerlink" title="get_unmapped_area"></a>get_unmapped_area</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[mm/mmap.c]</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span></span></span><br><span class="line"><span class="function"><span class="title">get_unmapped_area</span><span class="params">(struct file *file, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> len,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">unsigned</span> <span class="keyword">long</span> pgoff, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">long</span> <span class="params">(*get_area)</span><span class="params">(struct file *, <span class="keyword">unsigned</span> <span class="keyword">long</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> error = arch_mmap_check(addr, len, flags);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Careful about overflows.. */</span></span><br><span class="line">    <span class="keyword">if</span> (len &gt; TASK_SIZE)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    get_area = current-&gt;mm-&gt;get_unmapped_area;</span><br><span class="line">    <span class="keyword">if</span> (file) &#123;</span><br><span class="line">        <span class="keyword">if</span> (file-&gt;f_op-&gt;get_unmapped_area)</span><br><span class="line">            get_area = file-&gt;f_op-&gt;get_unmapped_area;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; MAP_SHARED) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * mmap_region() will call shmem_zero_setup() to create a file,</span></span><br><span class="line"><span class="comment">         * so use shmem&#x27;s get_unmapped_area in case it can be huge.</span></span><br><span class="line"><span class="comment">         * do_mmap() will clear pgoff, so match alignment.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        pgoff = <span class="number">0</span>;</span><br><span class="line">        get_area = shmem_get_unmapped_area;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addr = get_area(file, addr, len, pgoff, flags);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR_VALUE(addr))</span><br><span class="line">        <span class="keyword">return</span> addr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (addr &gt; TASK_SIZE - len)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    <span class="keyword">if</span> (offset_in_page(addr))</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    error = security_mmap_addr(addr);</span><br><span class="line">    <span class="keyword">return</span> error ? error : addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="arch-get-unmapped-area"><a href="#arch-get-unmapped-area" class="headerlink" title="arch_get_unmapped_area"></a>arch_get_unmapped_area</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[mm/mmap.c]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get an address range which is currently unmapped.</span></span><br><span class="line"><span class="comment"> * For shmat() with addr=0.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Ugly calling convention alert:</span></span><br><span class="line"><span class="comment"> * Return value with the low bits set means error value,</span></span><br><span class="line"><span class="comment"> * ie</span></span><br><span class="line"><span class="comment"> *	if (ret &amp; ~PAGE_MASK)</span></span><br><span class="line"><span class="comment"> *		error = ret;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function &quot;knows&quot; that -ENOMEM has the bits set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_ARCH_UNMAPPED_AREA</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span></span></span><br><span class="line"><span class="function"><span class="title">arch_get_unmapped_area</span><span class="params">(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">unsigned</span> <span class="keyword">long</span> len, <span class="keyword">unsigned</span> <span class="keyword">long</span> pgoff, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>, *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_unmapped_area_info</span> <span class="title">info</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> mmap_end = arch_get_mmap_end(addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &gt; mmap_end - mmap_min_addr)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MAP_FIXED)</span><br><span class="line">        <span class="keyword">return</span> addr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (addr) &#123;</span><br><span class="line">        addr = PAGE_ALIGN(addr);</span><br><span class="line">        vma = find_vma_prev(mm, addr, &amp;prev);</span><br><span class="line">        <span class="keyword">if</span> (mmap_end - len &gt;= addr &amp;&amp; addr &gt;= mmap_min_addr &amp;&amp;</span><br><span class="line">            (!vma || addr + len &lt;= vm_start_gap(vma)) &amp;&amp;</span><br><span class="line">            (!prev || addr &gt;= vm_end_gap(prev)))</span><br><span class="line">            <span class="keyword">return</span> addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    info.flags = <span class="number">0</span>;</span><br><span class="line">    info.length = len;</span><br><span class="line">    info.low_limit = mm-&gt;mmap_base;</span><br><span class="line">    info.high_limit = mmap_end;</span><br><span class="line">    info.align_mask = <span class="number">0</span>;</span><br><span class="line">    info.align_offset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> vm_unmapped_area(&amp;info);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<h4 id="find-vma-prev"><a href="#find-vma-prev" class="headerlink" title="find_vma_prev"></a>find_vma_prev</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[mm/mmap.c]</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Same as find_vma, but also return a pointer to the previous VMA in *pprev.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct vm_area_struct *</span></span><br><span class="line"><span class="function"><span class="title">find_vma_prev</span><span class="params">(struct mm_struct *mm, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr,</span></span></span><br><span class="line"><span class="params"><span class="function">            struct vm_area_struct **pprev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>;</span></span><br><span class="line"></span><br><span class="line">    vma = find_vma(mm, addr);</span><br><span class="line">    <span class="keyword">if</span> (vma) &#123;</span><br><span class="line">        *pprev = vma-&gt;vm_prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        struct rb_node *rb_node = rb_last(&amp;mm-&gt;mm_rb);</span><br><span class="line"></span><br><span class="line">        *pprev = rb_node ? rb_entry(rb_node, struct vm_area_struct, vm_rb) : <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vma;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="find-vma"><a href="#find-vma" class="headerlink" title="find_vma"></a>find_vma</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Look up the first VMA which satisfies  addr &lt; vm_end,  NULL if none. */</span></span><br><span class="line"><span class="function">struct vm_area_struct *<span class="title">find_vma</span><span class="params">(struct mm_struct *mm, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check the cache first. */</span></span><br><span class="line">    vma = vmacache_find(mm, addr);</span><br><span class="line">    <span class="keyword">if</span> (likely(vma))</span><br><span class="line">        <span class="keyword">return</span> vma;</span><br><span class="line"></span><br><span class="line">    rb_node = mm-&gt;mm_rb.rb_node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (rb_node) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">        tmp = rb_entry(rb_node, struct vm_area_struct, vm_rb);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tmp-&gt;vm_end &gt; addr) &#123;</span><br><span class="line">            vma = tmp;</span><br><span class="line">            <span class="keyword">if</span> (tmp-&gt;vm_start &lt;= addr)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            rb_node = rb_node-&gt;rb_left;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            rb_node = rb_node-&gt;rb_right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vma)</span><br><span class="line">        vmacache_update(addr, vma);</span><br><span class="line">    <span class="keyword">return</span> vma;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="vm-unmapped-area"><a href="#vm-unmapped-area" class="headerlink" title="vm_unmapped_area"></a>vm_unmapped_area</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[mm/mmap.c]</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Search for an unmapped address range.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We are looking for a range that:</span></span><br><span class="line"><span class="comment"> * - does not intersect with any VMA;</span></span><br><span class="line"><span class="comment"> * - is contained within the [low_limit, high_limit) interval;</span></span><br><span class="line"><span class="comment"> * - is at least the desired size.</span></span><br><span class="line"><span class="comment"> * - satisfies (begin_addr &amp; align_mask) == (align_offset &amp; align_mask)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">vm_unmapped_area</span><span class="params">(struct vm_unmapped_area_info *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> addr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info-&gt;flags &amp; VM_UNMAPPED_AREA_TOPDOWN)</span><br><span class="line">        addr = unmapped_area_topdown(info);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        addr = unmapped_area(info);</span><br><span class="line"></span><br><span class="line">    trace_vm_unmapped_area(addr, info);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Data-structure"><a href="#Data-structure" class="headerlink" title="Data structure"></a>Data structure</h3><h4 id="vm-area-struct"><a href="#vm-area-struct" class="headerlink" title="vm_area_struct"></a>vm_area_struct</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[include/linux/mm_types.h]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This struct defines a memory VMM memory area. There is one of these</span></span><br><span class="line"><span class="comment"> * per VM-area/task.  A VM area is any part of the process virtual memory</span></span><br><span class="line"><span class="comment"> * space that has a special rule for the page-fault handlers (ie a shared</span></span><br><span class="line"><span class="comment"> * library, the executable area etc).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> * <span class="title">vm_mm</span>;</span>	<span class="comment">/* The address space we belong to. */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> vm_start;		<span class="comment">/* Our start address within vm_mm. */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> vm_end;		<span class="comment">/* The first byte after our end address</span></span><br><span class="line"><span class="comment">					   within vm_mm. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* linked list of VM areas per task, sorted by address */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">pgprot_t</span> vm_page_prot;		<span class="comment">/* Access permissions of this VMA. */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> vm_flags;		<span class="comment">/* Flags, listed below. */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">vm_rb</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * For areas with an address space and backing store,</span></span><br><span class="line"><span class="comment">	 * linkage into the address_space-&gt;i_mmap prio tree, or</span></span><br><span class="line"><span class="comment">	 * linkage to the list of like vmas hanging off its node, or</span></span><br><span class="line"><span class="comment">	 * linkage of vma in the address_space-&gt;i_mmap_nonlinear list.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">			<span class="keyword">void</span> *parent;	<span class="comment">/* aligns with prio_tree_node parent */</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">head</span>;</span></span><br><span class="line">		&#125; vm_set;</span><br><span class="line"></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">raw_prio_tree_node</span> <span class="title">prio_tree_node</span>;</span></span><br><span class="line">	&#125; shared;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * A file&#x27;s MAP_PRIVATE vma can be in both i_mmap tree and anon_vma</span></span><br><span class="line"><span class="comment">	 * list, after a COW of one of the file pages.	A MAP_SHARED vma</span></span><br><span class="line"><span class="comment">	 * can only be in the i_mmap tree.  An anonymous MAP_PRIVATE, stack</span></span><br><span class="line"><span class="comment">	 * or brk vma (with NULL file) can only be in an anon_vma list.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">anon_vma_node</span>;</span>	<span class="comment">/* Serialized by anon_vma-&gt;lock */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">anon_vma</span> *<span class="title">anon_vma</span>;</span>	<span class="comment">/* Serialized by page_table_lock */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Function pointers to deal with this struct. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> * <span class="title">vm_ops</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Information about our backing store: */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> vm_pgoff;		<span class="comment">/* Offset (within vm_file) in PAGE_SIZE</span></span><br><span class="line"><span class="comment">					   units, *not* PAGE_CACHE_SIZE */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">vm_file</span>;</span>		<span class="comment">/* File we map to (can be NULL). */</span></span><br><span class="line">	<span class="keyword">void</span> * vm_private_data;		<span class="comment">/* was vm_pte (shared mem) */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> vm_truncate_count;<span class="comment">/* truncate_count or restart_addr */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line">	<span class="keyword">atomic_t</span> vm_usage;		<span class="comment">/* refcount (VMAs shared if !MMU) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mempolicy</span> *<span class="title">vm_policy</span>;</span>	<span class="comment">/* NUMA policy for the VMA */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="mm-struct"><a href="#mm-struct" class="headerlink" title="mm_struct"></a>mm_struct</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[include/linux/mm_types.h]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">mmap</span>;</span>		<span class="comment">/* list of VMAs */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">mm_rb</span>;</span></span><br><span class="line">		u64 vmacache_seqnum;                   <span class="comment">/* per-thread vmacache */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MMU</span></span><br><span class="line">		<span class="function"><span class="keyword">unsigned</span> <span class="title">long</span> <span class="params">(*get_unmapped_area)</span> <span class="params">(struct file *filp,</span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> len,</span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="keyword">unsigned</span> <span class="keyword">long</span> pgoff, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> mmap_base;	<span class="comment">/* base of mmap area */</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> mmap_legacy_base;	<span class="comment">/* base of mmap area in bottom-up allocations */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_HAVE_ARCH_COMPAT_MMAP_BASES</span></span><br><span class="line">		<span class="comment">/* Base adresses for compatible mmap() */</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> mmap_compat_base;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> mmap_compat_legacy_base;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> task_size;	<span class="comment">/* size of task vm space */</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> highest_vm_end;	<span class="comment">/* highest vma end address */</span></span><br><span class="line">		<span class="keyword">pgd_t</span> * pgd;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMBARRIER</span></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * @membarrier_state: Flags controlling membarrier behavior.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * This field is close to @pgd to hopefully fit in the same</span></span><br><span class="line"><span class="comment">		 * cache-line, which needs to be touched by switch_mm().</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">atomic_t</span> membarrier_state;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * @mm_users: The number of users including userspace.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * Use mmget()/mmget_not_zero()/mmput() to modify. When this</span></span><br><span class="line"><span class="comment">		 * drops to 0 (i.e. when the task exits and there are no other</span></span><br><span class="line"><span class="comment">		 * temporary reference holders), we also release a reference on</span></span><br><span class="line"><span class="comment">		 * @mm_count (which may then free the &amp;struct mm_struct if</span></span><br><span class="line"><span class="comment">		 * @mm_count also drops to 0).</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">atomic_t</span> mm_users;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * @mm_count: The number of references to &amp;struct mm_struct</span></span><br><span class="line"><span class="comment">		 * (@mm_users count as 1).</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * Use mmgrab()/mmdrop() to modify. When this drops to 0, the</span></span><br><span class="line"><span class="comment">		 * &amp;struct mm_struct is freed.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">atomic_t</span> mm_count;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * @has_pinned: Whether this mm has pinned any pages.  This can</span></span><br><span class="line"><span class="comment">		 * be either replaced in the future by @pinned_vm when it</span></span><br><span class="line"><span class="comment">		 * becomes stable, or grow into a counter on its own. We&#x27;re</span></span><br><span class="line"><span class="comment">		 * aggresive on this bit now - even if the pinned pages were</span></span><br><span class="line"><span class="comment">		 * unpinned later on, we&#x27;ll still keep this bit set for the</span></span><br><span class="line"><span class="comment">		 * lifecycle of this mm just for simplicity.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">atomic_t</span> has_pinned;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MMU</span></span><br><span class="line">		<span class="keyword">atomic_long_t</span> pgtables_bytes;	<span class="comment">/* PTE page table pages */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		<span class="keyword">int</span> map_count;			<span class="comment">/* number of VMAs */</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">spinlock_t</span> page_table_lock; <span class="comment">/* Protects page tables and some</span></span><br><span class="line"><span class="comment">					     * counters</span></span><br><span class="line"><span class="comment">					     */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">mmap_lock</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mmlist</span>;</span> <span class="comment">/* List of maybe swapped mm&#x27;s.	These</span></span><br><span class="line"><span class="comment">					  * are globally strung together off</span></span><br><span class="line"><span class="comment">					  * init_mm.mmlist, and are protected</span></span><br><span class="line"><span class="comment">					  * by mmlist_lock</span></span><br><span class="line"><span class="comment">					  */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> hiwater_rss; <span class="comment">/* High-watermark of RSS usage */</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> hiwater_vm;  <span class="comment">/* High-water virtual memory usage */</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> total_vm;	   <span class="comment">/* Total pages mapped */</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> locked_vm;   <span class="comment">/* Pages that have PG_mlocked set */</span></span><br><span class="line">		<span class="keyword">atomic64_t</span>    pinned_vm;   <span class="comment">/* Refcount permanently increased */</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> data_vm;	   <span class="comment">/* VM_WRITE &amp; ~VM_SHARED &amp; ~VM_STACK */</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> exec_vm;	   <span class="comment">/* VM_EXEC &amp; ~VM_WRITE &amp; ~VM_STACK */</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> stack_vm;	   <span class="comment">/* VM_STACK */</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> def_flags;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">spinlock_t</span> arg_lock; <span class="comment">/* protect the below fields */</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> start_code, end_code, start_data, end_data;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> start_brk, brk, start_stack;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> arg_start, arg_end, env_start, env_end;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> saved_auxv[AT_VECTOR_SIZE]; <span class="comment">/* for /proc/PID/auxv */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Special counters, in some configurations protected by the</span></span><br><span class="line"><span class="comment">		 * page_table_lock, in other configurations by being atomic.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">mm_rss_stat</span> <span class="title">rss_stat</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">linux_binfmt</span> *<span class="title">binfmt</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Architecture-specific MM context */</span></span><br><span class="line">		<span class="keyword">mm_context_t</span> context;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> flags; <span class="comment">/* Must use atomic bitops to access */</span></span><br><span class="line"></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">core_state</span> *<span class="title">core_state</span>;</span> <span class="comment">/* coredumping support */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_AIO</span></span><br><span class="line">		<span class="keyword">spinlock_t</span>			ioctx_lock;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">kioctx_table</span> __<span class="title">rcu</span>	*<span class="title">ioctx_table</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMCG</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * &quot;owner&quot; points to a task that is regarded as the canonical</span></span><br><span class="line"><span class="comment">		 * user/owner of this mm. All of the following must be true in</span></span><br><span class="line"><span class="comment">		 * order for it to be changed:</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * current == mm-&gt;owner</span></span><br><span class="line"><span class="comment">		 * current-&gt;mm != mm</span></span><br><span class="line"><span class="comment">		 * new_owner-&gt;mm == mm</span></span><br><span class="line"><span class="comment">		 * new_owner-&gt;alloc_lock is held</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> __<span class="title">rcu</span> *<span class="title">owner</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* store ref to file /proc/&lt;pid&gt;/exe symlink points to */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">file</span> __<span class="title">rcu</span> *<span class="title">exe_file</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MMU_NOTIFIER</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">mmu_notifier_subscriptions</span> *<span class="title">notifier_subscriptions</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_TRANSPARENT_HUGEPAGE) &amp;&amp; !USE_SPLIT_PMD_PTLOCKS</span></span><br><span class="line">		<span class="keyword">pgtable_t</span> pmd_huge_pte; <span class="comment">/* protected by page_table_lock */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA_BALANCING</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * numa_next_scan is the next time that the PTEs will be marked</span></span><br><span class="line"><span class="comment">		 * pte_numa. NUMA hinting faults will gather statistics and</span></span><br><span class="line"><span class="comment">		 * migrate pages to new nodes if necessary.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> numa_next_scan;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Restart point for scanning and setting pte_numa */</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> numa_scan_offset;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* numa_scan_seq prevents two threads setting pte_numa */</span></span><br><span class="line">		<span class="keyword">int</span> numa_scan_seq;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * An operation with batched TLB flushing is going on. Anything</span></span><br><span class="line"><span class="comment">		 * that can move process memory needs to flush the TLB when</span></span><br><span class="line"><span class="comment">		 * moving a PROT_NONE or PROT_NUMA mapped page.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">atomic_t</span> tlb_flush_pending;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ARCH_WANT_BATCHED_UNMAP_TLB_FLUSH</span></span><br><span class="line">		<span class="comment">/* See flush_tlb_batched_pending() */</span></span><br><span class="line">		<span class="keyword">bool</span> tlb_flush_batched;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">uprobes_state</span> <span class="title">uprobes_state</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_HUGETLB_PAGE</span></span><br><span class="line">		<span class="keyword">atomic_long_t</span> hugetlb_usage;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">async_put_work</span>;</span></span><br><span class="line">	&#125; __randomize_layout;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The mm_cpumask needs to be at the end of mm_struct, because it</span></span><br><span class="line"><span class="comment">	 * is dynamically sized based on nr_cpu_ids.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cpu_bitmap[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="缺页异常信息：vm-fault"><a href="#缺页异常信息：vm-fault" class="headerlink" title="缺页异常信息：vm_fault"></a>缺页异常信息：vm_fault</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[include/linux/mm.h]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_fault</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>;</span>	<span class="comment">/* Target VMA */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> flags;		<span class="comment">/* FAULT_FLAG_xxx flags */</span></span><br><span class="line">	<span class="keyword">gfp_t</span> gfp_mask;			<span class="comment">/* gfp mask to be used for allocations */</span></span><br><span class="line">	<span class="keyword">pgoff_t</span> pgoff;			<span class="comment">/* Logical page offset based on vma */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> address;		<span class="comment">/* Faulting virtual address */</span></span><br><span class="line">	<span class="keyword">pmd_t</span> *pmd;			<span class="comment">/* Pointer to pmd entry matching</span></span><br><span class="line"><span class="comment">					 * the &#x27;address&#x27; */</span></span><br><span class="line">	<span class="keyword">pud_t</span> *pud;			<span class="comment">/* Pointer to pud entry matching</span></span><br><span class="line"><span class="comment">					 * the &#x27;address&#x27;</span></span><br><span class="line"><span class="comment">					 */</span></span><br><span class="line">	<span class="keyword">pte_t</span> orig_pte;			<span class="comment">/* Value of PTE at the time of fault */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">cow_page</span>;</span>		<span class="comment">/* Page handler may use for COW fault */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span>		<span class="comment">/* -&gt;fault handlers should return a</span></span><br><span class="line"><span class="comment">					 * page here, unless VM_FAULT_NOPAGE</span></span><br><span class="line"><span class="comment">					 * is set (which is also implied by</span></span><br><span class="line"><span class="comment">					 * VM_FAULT_ERROR).</span></span><br><span class="line"><span class="comment">					 */</span></span><br><span class="line">	<span class="comment">/* These three entries are valid only while holding ptl lock */</span></span><br><span class="line">	<span class="keyword">pte_t</span> *pte;			<span class="comment">/* Pointer to pte entry matching</span></span><br><span class="line"><span class="comment">					 * the &#x27;address&#x27;. NULL if the page</span></span><br><span class="line"><span class="comment">					 * table hasn&#x27;t been allocated.</span></span><br><span class="line"><span class="comment">					 */</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> *ptl;		<span class="comment">/* Page table lock.</span></span><br><span class="line"><span class="comment">					 * Protects pte page table if &#x27;pte&#x27;</span></span><br><span class="line"><span class="comment">					 * is not NULL, otherwise pmd.</span></span><br><span class="line"><span class="comment">					 */</span></span><br><span class="line">	<span class="keyword">pgtable_t</span> prealloc_pte;		<span class="comment">/* Pre-allocated pte page table.</span></span><br><span class="line"><span class="comment">					 * vm_ops-&gt;map_pages() calls</span></span><br><span class="line"><span class="comment">					 * alloc_set_pte() from atomic context.</span></span><br><span class="line"><span class="comment">					 * do_fault_around() pre-allocates</span></span><br><span class="line"><span class="comment">					 * page table to avoid allocation from</span></span><br><span class="line"><span class="comment">					 * atomic context.</span></span><br><span class="line"><span class="comment">					 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="Page-Fault"><a href="#Page-Fault" class="headerlink" title="Page Fault"></a>Page Fault</h2><p>一旦开始访问虚拟内存的某个地址，如果我们发现，并没有对应的物理页，那就触发缺页中断，调用 do_page_fault()。这里的逻辑如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[mm/memory.c]</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * By the time we get here, we already hold the mm semaphore</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The mmap_lock may have been released depending on flags and our</span></span><br><span class="line"><span class="comment"> * return value.  See filemap_fault() and __lock_page_or_retry().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">vm_fault_t</span> <span class="title">handle_mm_fault</span><span class="params">(struct vm_area_struct *vma, <span class="keyword">unsigned</span> <span class="keyword">long</span> address,</span></span></span><br><span class="line"><span class="params"><span class="function">			   <span class="keyword">unsigned</span> <span class="keyword">int</span> flags, struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">vm_fault_t</span> ret;</span><br><span class="line"></span><br><span class="line">	__set_current_state(TASK_RUNNING);</span><br><span class="line"></span><br><span class="line">	count_vm_event(PGFAULT);</span><br><span class="line">	count_memcg_event_mm(vma-&gt;vm_mm, PGFAULT);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* do counter updates before entering really critical section. */</span></span><br><span class="line">	check_sync_rss_stat(current);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!arch_vma_access_permitted(vma, flags &amp; FAULT_FLAG_WRITE,</span><br><span class="line">					    flags &amp; FAULT_FLAG_INSTRUCTION,</span><br><span class="line">					    flags &amp; FAULT_FLAG_REMOTE))</span><br><span class="line">		<span class="keyword">return</span> VM_FAULT_SIGSEGV;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Enable the memcg OOM handling for faults triggered in user</span></span><br><span class="line"><span class="comment">	 * space.  Kernel faults are handled more gracefully.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; FAULT_FLAG_USER)</span><br><span class="line">		mem_cgroup_enter_user_fault();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(is_vm_hugetlb_page(vma)))</span><br><span class="line">		ret = hugetlb_fault(vma-&gt;vm_mm, vma, address, flags);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		ret = __handle_mm_fault(vma, address, flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; FAULT_FLAG_USER) &#123;</span><br><span class="line">		mem_cgroup_exit_user_fault();</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * The task may have entered a memcg OOM situation but</span></span><br><span class="line"><span class="comment">		 * if the allocation error was handled gracefully (no</span></span><br><span class="line"><span class="comment">		 * VM_FAULT_OOM), there is no need to kill anything.</span></span><br><span class="line"><span class="comment">		 * Just clean up the OOM state peacefully.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (task_in_memcg_oom(current) &amp;&amp; !(ret &amp; VM_FAULT_OOM))</span><br><span class="line">			mem_cgroup_oom_synchronize(<span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mm_account_fault(regs, address, flags, ret);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">vm_fault_t</span> __handle_mm_fault(struct vm_area_struct *vma,</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> address, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_fault</span> <span class="title">vmf</span> =</span> &#123;</span><br><span class="line">		.vma = vma,</span><br><span class="line">		.address = address &amp; PAGE_MASK,</span><br><span class="line">		.flags = flags,</span><br><span class="line">		.pgoff = linear_page_index(vma, address),</span><br><span class="line">		.gfp_mask = __get_fault_gfp_mask(vma),</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> dirty = flags &amp; FAULT_FLAG_WRITE;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> vma-&gt;vm_mm;</span><br><span class="line">	<span class="keyword">pgd_t</span> *pgd;</span><br><span class="line">	<span class="keyword">p4d_t</span> *p4d;</span><br><span class="line">	<span class="keyword">vm_fault_t</span> ret;</span><br><span class="line"></span><br><span class="line">	pgd = pgd_offset(mm, address);</span><br><span class="line">	p4d = p4d_alloc(mm, pgd, address);</span><br><span class="line">	<span class="keyword">if</span> (!p4d)</span><br><span class="line">		<span class="keyword">return</span> VM_FAULT_OOM;</span><br><span class="line"></span><br><span class="line">	vmf.pud = pud_alloc(mm, p4d, address);</span><br><span class="line">	<span class="keyword">if</span> (!vmf.pud)</span><br><span class="line">		<span class="keyword">return</span> VM_FAULT_OOM;</span><br><span class="line">retry_pud:</span><br><span class="line">	<span class="keyword">if</span> (pud_none(*vmf.pud) &amp;&amp; __transparent_hugepage_enabled(vma)) &#123;</span><br><span class="line">		ret = create_huge_pud(&amp;vmf);</span><br><span class="line">		<span class="keyword">if</span> (!(ret &amp; VM_FAULT_FALLBACK))</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">pud_t</span> orig_pud = *vmf.pud;</span><br><span class="line"></span><br><span class="line">		barrier();</span><br><span class="line">		<span class="keyword">if</span> (pud_trans_huge(orig_pud) || pud_devmap(orig_pud)) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* NUMA case for anonymous PUDs would go here */</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (dirty &amp;&amp; !pud_write(orig_pud)) &#123;</span><br><span class="line">				ret = wp_huge_pud(&amp;vmf, orig_pud);</span><br><span class="line">				<span class="keyword">if</span> (!(ret &amp; VM_FAULT_FALLBACK))</span><br><span class="line">					<span class="keyword">return</span> ret;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				huge_pud_set_accessed(&amp;vmf, orig_pud);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vmf.pmd = pmd_alloc(mm, vmf.pud, address);</span><br><span class="line">	<span class="keyword">if</span> (!vmf.pmd)</span><br><span class="line">		<span class="keyword">return</span> VM_FAULT_OOM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Huge pud page fault raced with pmd_alloc? */</span></span><br><span class="line">	<span class="keyword">if</span> (pud_trans_unstable(vmf.pud))</span><br><span class="line">		<span class="keyword">goto</span> retry_pud;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pmd_none(*vmf.pmd) &amp;&amp; __transparent_hugepage_enabled(vma)) &#123;</span><br><span class="line">		ret = create_huge_pmd(&amp;vmf);</span><br><span class="line">		<span class="keyword">if</span> (!(ret &amp; VM_FAULT_FALLBACK))</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">pmd_t</span> orig_pmd = *vmf.pmd;</span><br><span class="line"></span><br><span class="line">		barrier();</span><br><span class="line">		<span class="keyword">if</span> (unlikely(is_swap_pmd(orig_pmd))) &#123;</span><br><span class="line">			VM_BUG_ON(thp_migration_supported() &amp;&amp;</span><br><span class="line">					  !is_pmd_migration_entry(orig_pmd));</span><br><span class="line">			<span class="keyword">if</span> (is_pmd_migration_entry(orig_pmd))</span><br><span class="line">				pmd_migration_entry_wait(mm, vmf.pmd);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (pmd_trans_huge(orig_pmd) || pmd_devmap(orig_pmd)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (pmd_protnone(orig_pmd) &amp;&amp; vma_is_accessible(vma))</span><br><span class="line">				<span class="keyword">return</span> do_huge_pmd_numa_page(&amp;vmf, orig_pmd);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (dirty &amp;&amp; !pmd_write(orig_pmd)) &#123;</span><br><span class="line">				ret = wp_huge_pmd(&amp;vmf, orig_pmd);</span><br><span class="line">				<span class="keyword">if</span> (!(ret &amp; VM_FAULT_FALLBACK))</span><br><span class="line">					<span class="keyword">return</span> ret;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				huge_pmd_set_accessed(&amp;vmf, orig_pmd);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> handle_pte_fault(&amp;vmf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="handle-pte-fault"><a href="#handle-pte-fault" class="headerlink" title="handle_pte_fault"></a>handle_pte_fault</h4><p> handle_pte_fault()是处理页表项（Page Table Entry，PTE）故障的核心函数。它的作用是在发生页故障时，根据页表项的状态和vma的属性来处理不同的缺页情况。主要处理流程：</p>
<p>如果vma是匿名映射，则会调用do_anonymous_page()函数为匿名页分配物理内存（pte_alloc），</p>
<p>如果vma是文件映射，则会调用do_fault()函数，它会从文件系统中读取数据到页缓存中，并更新页表项以反映新的物理页面映射；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">vm_fault_t</span> <span class="title">handle_pte_fault</span><span class="params">(struct vm_fault *vmf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pte_t</span> entry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(pmd_none(*vmf-&gt;pmd))) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Leave __pte_alloc() until later: because vm_ops-&gt;fault may</span></span><br><span class="line"><span class="comment">         * want to allocate huge page, and if we expose page table</span></span><br><span class="line"><span class="comment">         * for an instant, it will be difficult to retract from</span></span><br><span class="line"><span class="comment">         * concurrent faults and from rmap lookups.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        vmf-&gt;pte = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* See comment in pte_alloc_one_map() */</span></span><br><span class="line">        <span class="keyword">if</span> (pmd_devmap_trans_unstable(vmf-&gt;pmd))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * A regular pmd is established and it can&#x27;t morph into a huge</span></span><br><span class="line"><span class="comment">         * pmd from under us anymore at this point because we hold the</span></span><br><span class="line"><span class="comment">         * mmap_lock read mode and khugepaged takes it in write mode.</span></span><br><span class="line"><span class="comment">         * So now it&#x27;s safe to run pte_offset_map().</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        vmf-&gt;pte = pte_offset_map(vmf-&gt;pmd, vmf-&gt;address);</span><br><span class="line">        vmf-&gt;orig_pte = *vmf-&gt;pte;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * some architectures can have larger ptes than wordsize,</span></span><br><span class="line"><span class="comment">         * e.g.ppc44x-defconfig has CONFIG_PTE_64BIT=y and</span></span><br><span class="line"><span class="comment">         * CONFIG_32BIT=y, so READ_ONCE cannot guarantee atomic</span></span><br><span class="line"><span class="comment">         * accesses.  The code below just needs a consistent view</span></span><br><span class="line"><span class="comment">         * for the ifs and we later double check anyway with the</span></span><br><span class="line"><span class="comment">         * ptl lock held. So here a barrier will do.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        barrier();</span><br><span class="line">        <span class="keyword">if</span> (pte_none(vmf-&gt;orig_pte)) &#123;</span><br><span class="line">            pte_unmap(vmf-&gt;pte);</span><br><span class="line">            vmf-&gt;pte = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!vmf-&gt;pte) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vma_is_anonymous(vmf-&gt;vma))</span><br><span class="line">            <span class="keyword">return</span> do_anonymous_page(vmf);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> do_fault(vmf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pte_present(vmf-&gt;orig_pte))</span><br><span class="line">        <span class="keyword">return</span> do_swap_page(vmf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pte_protnone(vmf-&gt;orig_pte) &amp;&amp; vma_is_accessible(vmf-&gt;vma))</span><br><span class="line">        <span class="keyword">return</span> do_numa_page(vmf);</span><br><span class="line"></span><br><span class="line">    vmf-&gt;ptl = pte_lockptr(vmf-&gt;vma-&gt;vm_mm, vmf-&gt;pmd);</span><br><span class="line">    spin_lock(vmf-&gt;ptl);</span><br><span class="line">    entry = vmf-&gt;orig_pte;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(!pte_same(*vmf-&gt;pte, entry))) &#123;</span><br><span class="line">        update_mmu_tlb(vmf-&gt;vma, vmf-&gt;address, vmf-&gt;pte);</span><br><span class="line">        <span class="keyword">goto</span> unlock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vmf-&gt;flags &amp; FAULT_FLAG_WRITE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!pte_write(entry))</span><br><span class="line">            <span class="keyword">return</span> do_wp_page(vmf);</span><br><span class="line">        entry = pte_mkdirty(entry);</span><br><span class="line">    &#125;</span><br><span class="line">    entry = pte_mkyoung(entry);</span><br><span class="line">    <span class="keyword">if</span> (ptep_set_access_flags(vmf-&gt;vma, vmf-&gt;address, vmf-&gt;pte, entry,</span><br><span class="line">                vmf-&gt;flags &amp; FAULT_FLAG_WRITE)) &#123;</span><br><span class="line">        update_mmu_cache(vmf-&gt;vma, vmf-&gt;address, vmf-&gt;pte);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Skip spurious TLB flush for retried page fault */</span></span><br><span class="line">        <span class="keyword">if</span> (vmf-&gt;flags &amp; FAULT_FLAG_TRIED)</span><br><span class="line">            <span class="keyword">goto</span> unlock;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This is needed only for protection faults but the arch code</span></span><br><span class="line"><span class="comment">         * is not yet telling us if this is a protection fault or not.</span></span><br><span class="line"><span class="comment">         * This still avoids useless tlb flushes for .text page faults</span></span><br><span class="line"><span class="comment">         * with threads.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (vmf-&gt;flags &amp; FAULT_FLAG_WRITE)</span><br><span class="line">            flush_tlb_fix_spurious_fault(vmf-&gt;vma, vmf-&gt;address);</span><br><span class="line">    &#125;</span><br><span class="line">unlock:</span><br><span class="line">    pte_unmap_unlock(vmf-&gt;pte, vmf-&gt;ptl);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="do-fault"><a href="#do-fault" class="headerlink" title="do_fault"></a>do_fault</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">vm_fault_t</span> <span class="title">do_fault</span><span class="params">(struct vm_fault *vmf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span> =</span> vmf-&gt;vma;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span> =</span> vma-&gt;vm_mm;</span><br><span class="line">    <span class="keyword">vm_fault_t</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The VMA was not fully populated on mmap() or missing VM_DONTEXPAND</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!vma-&gt;vm_ops-&gt;fault) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If we find a migration pmd entry or a none pmd entry, which</span></span><br><span class="line"><span class="comment">         * should never happen, return SIGBUS</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(!pmd_present(*vmf-&gt;pmd)))</span><br><span class="line">            ret = VM_FAULT_SIGBUS;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            vmf-&gt;pte = pte_offset_map_lock(vmf-&gt;vma-&gt;vm_mm,</span><br><span class="line">                               vmf-&gt;pmd,</span><br><span class="line">                               vmf-&gt;address,</span><br><span class="line">                               &amp;vmf-&gt;ptl);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Make sure this is not a temporary clearing of pte</span></span><br><span class="line"><span class="comment">             * by holding ptl and checking again. A R/M/W update</span></span><br><span class="line"><span class="comment">             * of pte involves: take ptl, clearing the pte so that</span></span><br><span class="line"><span class="comment">             * we don&#x27;t have concurrent modification by hardware</span></span><br><span class="line"><span class="comment">             * followed by an update.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (unlikely(pte_none(*vmf-&gt;pte)))</span><br><span class="line">                ret = VM_FAULT_SIGBUS;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ret = VM_FAULT_NOPAGE;</span><br><span class="line"></span><br><span class="line">            pte_unmap_unlock(vmf-&gt;pte, vmf-&gt;ptl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(vmf-&gt;flags &amp; FAULT_FLAG_WRITE))</span><br><span class="line">        ret = do_read_fault(vmf);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; VM_SHARED))</span><br><span class="line">        ret = do_cow_fault(vmf);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ret = do_shared_fault(vmf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* preallocated pagetable is unused: free it */</span></span><br><span class="line">    <span class="keyword">if</span> (vmf-&gt;prealloc_pte) &#123;</span><br><span class="line">        pte_free(vm_mm, vmf-&gt;prealloc_pte);</span><br><span class="line">        vmf-&gt;prealloc_pte = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="do-cow-fault"><a href="#do-cow-fault" class="headerlink" title="do_cow_fault"></a>do_cow_fault</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[mm/memory.c]</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">vm_fault_t</span> <span class="title">do_cow_fault</span><span class="params">(struct vm_fault *vmf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span> =</span> vmf-&gt;vma;</span><br><span class="line">    <span class="keyword">vm_fault_t</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(anon_vma_prepare(vma)))</span><br><span class="line">        <span class="keyword">return</span> VM_FAULT_OOM;</span><br><span class="line"></span><br><span class="line">    vmf-&gt;cow_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, vmf-&gt;address);</span><br><span class="line">    <span class="keyword">if</span> (!vmf-&gt;cow_page)</span><br><span class="line">        <span class="keyword">return</span> VM_FAULT_OOM;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mem_cgroup_charge(vmf-&gt;cow_page, vma-&gt;vm_mm, GFP_KERNEL)) &#123;</span><br><span class="line">        put_page(vmf-&gt;cow_page);</span><br><span class="line">        <span class="keyword">return</span> VM_FAULT_OOM;</span><br><span class="line">    &#125;</span><br><span class="line">    cgroup_throttle_swaprate(vmf-&gt;cow_page, GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    ret = __do_fault(vmf);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(ret &amp; (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY)))</span><br><span class="line">        <span class="keyword">goto</span> uncharge_out;</span><br><span class="line">    <span class="keyword">if</span> (ret &amp; VM_FAULT_DONE_COW)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将fault page页面的内容复制到新分配的vmf-&gt;cow_page页面中。</span></span><br><span class="line">    copy_user_highpage(vmf-&gt;cow_page, vmf-&gt;page, vmf-&gt;address, vma);</span><br><span class="line">    __SetPageUptodate(vmf-&gt;cow_page);</span><br><span class="line"></span><br><span class="line">    ret |= finish_fault(vmf);</span><br><span class="line">    unlock_page(vmf-&gt;page);</span><br><span class="line">    put_page(vmf-&gt;page);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(ret &amp; (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY)))</span><br><span class="line">        <span class="keyword">goto</span> uncharge_out;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">uncharge_out:</span><br><span class="line">    put_page(vmf-&gt;cow_page);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="do-fault-1"><a href="#do-fault-1" class="headerlink" title="__do_fault"></a>__do_fault</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">vm_fault_t</span> __do_fault(struct vm_fault *vmf)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span> =</span> vmf-&gt;vma;</span><br><span class="line">    <span class="keyword">vm_fault_t</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pmd_none(*vmf-&gt;pmd) &amp;&amp; !vmf-&gt;prealloc_pte) &#123;</span><br><span class="line">        vmf-&gt;prealloc_pte = pte_alloc_one(vmf-&gt;vma-&gt;vm_mm);</span><br><span class="line">        <span class="keyword">if</span> (!vmf-&gt;prealloc_pte)</span><br><span class="line">            <span class="keyword">return</span> VM_FAULT_OOM;</span><br><span class="line">        smp_wmb(); <span class="comment">/* See comment in __pte_alloc() */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用文件的缺页异常函数进行处理.</span></span><br><span class="line">    ret = vma-&gt;vm_ops-&gt;fault(vmf);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(ret &amp; (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY |</span><br><span class="line">                VM_FAULT_DONE_COW)))</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不能分配到锁定在内存中的页.</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(PageHWPoison(vmf-&gt;page))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ret &amp; VM_FAULT_LOCKED)</span><br><span class="line">            unlock_page(vmf-&gt;page);</span><br><span class="line">        put_page(vmf-&gt;page);</span><br><span class="line">        vmf-&gt;page = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> VM_FAULT_HWPOISON;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!(ret &amp; VM_FAULT_LOCKED)))</span><br><span class="line">        lock_page(vmf-&gt;page);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        VM_BUG_ON_PAGE(!PageLocked(vmf-&gt;page), vmf-&gt;page);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="shmem-fault"><a href="#shmem-fault" class="headerlink" title="shmem_fault"></a>shmem_fault</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[mm/shmem.c]</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">vm_fault_t</span> <span class="title">shmem_fault</span><span class="params">(struct vm_fault *vmf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span> =</span> vmf-&gt;vma;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> file_inode(vma-&gt;vm_file);</span><br><span class="line">    <span class="keyword">gfp_t</span> gfp = mapping_gfp_mask(inode-&gt;i_mapping);</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">sgp_type</span> <span class="title">sgp</span>;</span></span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">vm_fault_t</span> ret = VM_FAULT_LOCKED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(inode-&gt;i_private)) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">shmem_falloc</span> *<span class="title">shmem_falloc</span>;</span></span><br><span class="line"></span><br><span class="line">        spin_lock(&amp;inode-&gt;i_lock);</span><br><span class="line">        shmem_falloc = inode-&gt;i_private;</span><br><span class="line">        <span class="keyword">if</span> (shmem_falloc &amp;&amp;</span><br><span class="line">            shmem_falloc-&gt;waitq &amp;&amp;</span><br><span class="line">            vmf-&gt;pgoff &gt;= shmem_falloc-&gt;start &amp;&amp;</span><br><span class="line">            vmf-&gt;pgoff &lt; shmem_falloc-&gt;next) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">fpin</span>;</span></span><br><span class="line">            <span class="keyword">wait_queue_head_t</span> *shmem_falloc_waitq;</span><br><span class="line">            DEFINE_WAIT_FUNC(shmem_fault_wait, synchronous_wake_function);</span><br><span class="line"></span><br><span class="line">            ret = VM_FAULT_NOPAGE;</span><br><span class="line">            fpin = maybe_unlock_mmap_for_io(vmf, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (fpin)</span><br><span class="line">                ret = VM_FAULT_RETRY;</span><br><span class="line"></span><br><span class="line">            shmem_falloc_waitq = shmem_falloc-&gt;waitq;</span><br><span class="line">            prepare_to_wait(shmem_falloc_waitq, &amp;shmem_fault_wait,</span><br><span class="line">                    TASK_UNINTERRUPTIBLE);</span><br><span class="line">            spin_unlock(&amp;inode-&gt;i_lock);</span><br><span class="line">            schedule();</span><br><span class="line"></span><br><span class="line">            spin_lock(&amp;inode-&gt;i_lock);</span><br><span class="line">            finish_wait(shmem_falloc_waitq, &amp;shmem_fault_wait);</span><br><span class="line">            spin_unlock(&amp;inode-&gt;i_lock);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fpin)</span><br><span class="line">                fput(fpin);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        spin_unlock(&amp;inode-&gt;i_lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sgp = SGP_CACHE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((vma-&gt;vm_flags &amp; VM_NOHUGEPAGE) ||</span><br><span class="line">        test_bit(MMF_DISABLE_THP, &amp;vma-&gt;vm_mm-&gt;flags))</span><br><span class="line">        sgp = SGP_NOHUGE;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (vma-&gt;vm_flags &amp; VM_HUGEPAGE)</span><br><span class="line">        sgp = SGP_HUGE;</span><br><span class="line"></span><br><span class="line">    err = shmem_getpage_gfp(inode, vmf-&gt;pgoff, &amp;vmf-&gt;page, sgp,</span><br><span class="line">                  gfp, vma, vmf, &amp;ret);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">return</span> vmf_error(err);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="filemap-fault"><a href="#filemap-fault" class="headerlink" title="filemap_fault"></a>filemap_fault</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[mm/filemap.c]</span></span><br><span class="line"><span class="function"><span class="keyword">vm_fault_t</span> <span class="title">filemap_fault</span><span class="params">(struct vm_fault *vmf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    <span class="comment">//获取映射文件.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span> =</span> vmf-&gt;vma-&gt;vm_file;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">fpin</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//获取page cache.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span> =</span> file-&gt;f_mapping;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_ra_state</span> *<span class="title">ra</span> =</span> &amp;file-&gt;f_ra;</span><br><span class="line">    <span class="comment">//获取映射文件的inode.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> mapping-&gt;host;</span><br><span class="line">    <span class="keyword">pgoff_t</span> offset = vmf-&gt;pgoff;</span><br><span class="line">    <span class="comment">//从page cache 读取到的文件页，存放在vmf-&gt;page中返回.</span></span><br><span class="line">    <span class="keyword">pgoff_t</span> max_off;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="keyword">vm_fault_t</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    max_off = DIV_ROUND_UP(i_size_read(inode), PAGE_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(offset &gt;= max_off))</span><br><span class="line">        <span class="keyword">return</span> VM_FAULT_SIGBUS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据文件偏移offset到page cache中查找对应的文件页.</span></span><br><span class="line">    page = find_get_page(mapping, offset);</span><br><span class="line">    <span class="keyword">if</span> (likely(page) &amp;&amp; !(vmf-&gt;flags &amp; FAULT_FLAG_TRIED)) &#123;</span><br><span class="line">        <span class="comment">//如果文件页在 page cache 中，则启动异步预读，预读后面的若干文件页到 page cache 中.</span></span><br><span class="line">        fpin = do_async_mmap_readahead(vmf, page);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!page) &#123;</span><br><span class="line">        <span class="comment">//如果文件页不在 page cache，那么就需要启动io从文件中读取内容到 page cache.</span></span><br><span class="line">        <span class="comment">//由于涉及到了磁盘io，所以本次缺页类型为 VM_FAULT_MAJOR.</span></span><br><span class="line">        count_vm_event(PGMAJFAULT);</span><br><span class="line">        count_memcg_event_mm(vmf-&gt;vma-&gt;vm_mm, PGMAJFAULT);</span><br><span class="line">        ret = VM_FAULT_MAJOR;</span><br><span class="line">        <span class="comment">//启动同步预读，将所需的文件数据读取进 page cache 中并同步预读若干相邻的文件数据到 page cache.</span></span><br><span class="line">        fpin = do_sync_mmap_readahead(vmf);</span><br><span class="line">retry_find:</span><br><span class="line">        <span class="comment">//尝试到 page cache 中重新读取文件页，这一次就可以读到了.</span></span><br><span class="line">        page = pagecache_get_page(mapping, offset,</span><br><span class="line">                      FGP_CREAT|FGP_FOR_MMAP,</span><br><span class="line">                      vmf-&gt;gfp_mask);</span><br><span class="line">        <span class="keyword">if</span> (!page) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fpin)</span><br><span class="line">                <span class="keyword">goto</span> out_retry;</span><br><span class="line">            <span class="keyword">return</span> VM_FAULT_OOM;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!lock_page_maybe_drop_mmap(vmf, page, &amp;fpin))</span><br><span class="line">        <span class="keyword">goto</span> out_retry;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Did it get truncated? */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(compound_head(page)-&gt;mapping != mapping)) &#123;</span><br><span class="line">        unlock_page(page);</span><br><span class="line">        put_page(page);</span><br><span class="line">        <span class="keyword">goto</span> retry_find;</span><br><span class="line">    &#125;</span><br><span class="line">    VM_BUG_ON_PAGE(page_to_pgoff(page) != offset, page);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We have a locked page in the page cache, now we need to check</span></span><br><span class="line"><span class="comment">     * that it&#x27;s up-to-date. If not, it is going to be due to an error.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!PageUptodate(page)))</span><br><span class="line">        <span class="keyword">goto</span> page_not_uptodate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We&#x27;ve made it this far and we had to drop our mmap_lock, now is the</span></span><br><span class="line"><span class="comment">     * time to return to the upper layer and have it re-find the vma and</span></span><br><span class="line"><span class="comment">     * redo the fault.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (fpin) &#123;</span><br><span class="line">        unlock_page(page);</span><br><span class="line">        <span class="keyword">goto</span> out_retry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Found the page and have a reference on it.</span></span><br><span class="line"><span class="comment">     * We must recheck i_size under page lock.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    max_off = DIV_ROUND_UP(i_size_read(inode), PAGE_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(offset &gt;= max_off)) &#123;</span><br><span class="line">        unlock_page(page);</span><br><span class="line">        put_page(page);</span><br><span class="line">        <span class="keyword">return</span> VM_FAULT_SIGBUS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vmf-&gt;page = page;</span><br><span class="line">    <span class="keyword">return</span> ret | VM_FAULT_LOCKED;</span><br><span class="line"></span><br><span class="line">page_not_uptodate:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Umm, take care of errors if the page isn&#x27;t up-to-date.</span></span><br><span class="line"><span class="comment">     * Try to re-read it _once_. We do this synchronously,</span></span><br><span class="line"><span class="comment">     * because there really aren&#x27;t any performance issues here</span></span><br><span class="line"><span class="comment">     * and we need to check for errors.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ClearPageError(page);</span><br><span class="line">    fpin = maybe_unlock_mmap_for_io(vmf, fpin);</span><br><span class="line">    error = mapping-&gt;a_ops-&gt;readpage(file, page);</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        wait_on_page_locked(page);</span><br><span class="line">        <span class="keyword">if</span> (!PageUptodate(page))</span><br><span class="line">            error = -EIO;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fpin)</span><br><span class="line">        <span class="keyword">goto</span> out_retry;</span><br><span class="line">    put_page(page);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!error || error == AOP_TRUNCATED_PAGE)</span><br><span class="line">        <span class="keyword">goto</span> retry_find;</span><br><span class="line"></span><br><span class="line">    shrink_readahead_size_eio(ra);</span><br><span class="line">    <span class="keyword">return</span> VM_FAULT_SIGBUS;</span><br><span class="line"></span><br><span class="line">out_retry:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We dropped the mmap_lock, we need to return to the fault handler to</span></span><br><span class="line"><span class="comment">     * re-find the vma and come back and find our hopefully still populated</span></span><br><span class="line"><span class="comment">     * page.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (page)</span><br><span class="line">        put_page(page);</span><br><span class="line">    <span class="keyword">if</span> (fpin)</span><br><span class="line">        fput(fpin);</span><br><span class="line">    <span class="keyword">return</span> ret | VM_FAULT_RETRY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="do-anonymous-page"><a href="#do-anonymous-page" class="headerlink" title="do_anonymous_page"></a>do_anonymous_page</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[mm/memory.c]</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">vm_fault_t</span> <span class="title">do_anonymous_page</span><span class="params">(struct vm_fault *vmf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span> =</span> vmf-&gt;vma;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="keyword">vm_fault_t</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">pte_t</span> entry;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* File mapping without -&gt;vm_ops ? */</span></span><br><span class="line">    <span class="keyword">if</span> (vma-&gt;vm_flags &amp; VM_SHARED)</span><br><span class="line">        <span class="keyword">return</span> VM_FAULT_SIGBUS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pte_alloc(vma-&gt;vm_mm, vmf-&gt;pmd))</span><br><span class="line">        <span class="keyword">return</span> VM_FAULT_OOM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* See the comment in pte_alloc_one_map() */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(pmd_trans_unstable(vmf-&gt;pmd)))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Use the zero-page for reads */</span></span><br><span class="line">    <span class="keyword">if</span> (!(vmf-&gt;flags &amp; FAULT_FLAG_WRITE) &amp;&amp;</span><br><span class="line">            !mm_forbids_zeropage(vma-&gt;vm_mm)) &#123;</span><br><span class="line">        entry = pte_mkspecial(pfn_pte(my_zero_pfn(vmf-&gt;address),</span><br><span class="line">                        vma-&gt;vm_page_prot));</span><br><span class="line">        vmf-&gt;pte = pte_offset_map_lock(vma-&gt;vm_mm, vmf-&gt;pmd,</span><br><span class="line">                vmf-&gt;address, &amp;vmf-&gt;ptl);</span><br><span class="line">        <span class="keyword">if</span> (!pte_none(*vmf-&gt;pte)) &#123;</span><br><span class="line">            update_mmu_tlb(vma, vmf-&gt;address, vmf-&gt;pte);</span><br><span class="line">            <span class="keyword">goto</span> unlock;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = check_stable_address_space(vma-&gt;vm_mm);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">            <span class="keyword">goto</span> unlock;</span><br><span class="line">        <span class="comment">/* Deliver the page fault to userland, check inside PT lock */</span></span><br><span class="line">        <span class="keyword">if</span> (userfaultfd_missing(vma)) &#123;</span><br><span class="line">            pte_unmap_unlock(vmf-&gt;pte, vmf-&gt;ptl);</span><br><span class="line">            <span class="keyword">return</span> handle_userfault(vmf, VM_UFFD_MISSING);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> setpte;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate our own private page. */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(anon_vma_prepare(vma)))</span><br><span class="line">        <span class="keyword">goto</span> oom;</span><br><span class="line">    page = alloc_zeroed_user_highpage_movable(vma, vmf-&gt;address);</span><br><span class="line">    <span class="keyword">if</span> (!page)</span><br><span class="line">        <span class="keyword">goto</span> oom;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mem_cgroup_charge(page, vma-&gt;vm_mm, GFP_KERNEL))</span><br><span class="line">        <span class="keyword">goto</span> oom_free_page;</span><br><span class="line">    cgroup_throttle_swaprate(page, GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The memory barrier inside __SetPageUptodate makes sure that</span></span><br><span class="line"><span class="comment">     * preceding stores to the page contents become visible before</span></span><br><span class="line"><span class="comment">     * the set_pte_at() write.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    __SetPageUptodate(page);</span><br><span class="line"></span><br><span class="line">    entry = mk_pte(page, vma-&gt;vm_page_prot);</span><br><span class="line">    entry = pte_sw_mkyoung(entry);</span><br><span class="line">    <span class="keyword">if</span> (vma-&gt;vm_flags &amp; VM_WRITE)</span><br><span class="line">        entry = pte_mkwrite(pte_mkdirty(entry));</span><br><span class="line"></span><br><span class="line">    vmf-&gt;pte = pte_offset_map_lock(vma-&gt;vm_mm, vmf-&gt;pmd, vmf-&gt;address,</span><br><span class="line">            &amp;vmf-&gt;ptl);</span><br><span class="line">    <span class="keyword">if</span> (!pte_none(*vmf-&gt;pte)) &#123;</span><br><span class="line">        update_mmu_cache(vma, vmf-&gt;address, vmf-&gt;pte);</span><br><span class="line">        <span class="keyword">goto</span> release;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = check_stable_address_space(vma-&gt;vm_mm);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">goto</span> release;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Deliver the page fault to userland, check inside PT lock */</span></span><br><span class="line">    <span class="keyword">if</span> (userfaultfd_missing(vma)) &#123;</span><br><span class="line">        pte_unmap_unlock(vmf-&gt;pte, vmf-&gt;ptl);</span><br><span class="line">        put_page(page);</span><br><span class="line">        <span class="keyword">return</span> handle_userfault(vmf, VM_UFFD_MISSING);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inc_mm_counter_fast(vma-&gt;vm_mm, MM_ANONPAGES);</span><br><span class="line">    page_add_new_anon_rmap(page, vma, vmf-&gt;address, <span class="literal">false</span>);</span><br><span class="line">    lru_cache_add_inactive_or_unevictable(page, vma);</span><br><span class="line">setpte:</span><br><span class="line">    set_pte_at(vma-&gt;vm_mm, vmf-&gt;address, vmf-&gt;pte, entry);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* No need to invalidate - it was non-present before */</span></span><br><span class="line">    update_mmu_cache(vma, vmf-&gt;address, vmf-&gt;pte);</span><br><span class="line">unlock:</span><br><span class="line">    pte_unmap_unlock(vmf-&gt;pte, vmf-&gt;ptl);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">release:</span><br><span class="line">    put_page(page);</span><br><span class="line">    <span class="keyword">goto</span> unlock;</span><br><span class="line">oom_free_page:</span><br><span class="line">    put_page(page);</span><br><span class="line">oom:</span><br><span class="line">    <span class="keyword">return</span> VM_FAULT_OOM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="alloc-zeroed-user-highpage-movable"><a href="#alloc-zeroed-user-highpage-movable" class="headerlink" title="alloc_zeroed_user_highpage_movable"></a>alloc_zeroed_user_highpage_movable</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[include/linux/highmem.h]</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct page *</span></span><br><span class="line"><span class="function"><span class="title">alloc_zeroed_user_highpage_movable</span><span class="params">(struct vm_area_struct *vma,</span></span></span><br><span class="line"><span class="params"><span class="function">					<span class="keyword">unsigned</span> <span class="keyword">long</span> vaddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> __alloc_zeroed_user_highpage(__GFP_MOVABLE, vma, vaddr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[arch/ia64/include/asm/page.h]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __alloc_zeroed_user_highpage(movableflags, vma, vaddr)		\</span></span><br><span class="line"><span class="meta">(&#123;									\</span></span><br><span class="line"><span class="meta">	struct page *page = alloc_page_vma(				\</span></span><br><span class="line"><span class="meta">		GFP_HIGHUSER | __GFP_ZERO | movableflags, vma, vaddr);	\</span></span><br><span class="line"><span class="meta">	<span class="meta-keyword">if</span> (page)							\</span></span><br><span class="line"><span class="meta"> 		flush_dcache_page(page);				\</span></span><br><span class="line"><span class="meta">	page;								\</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//[include/linux/highmem.h]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __HAVE_ARCH_ALLOC_ZEROED_USER_HIGHPAGE</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * __alloc_zeroed_user_highpage - Allocate a zeroed HIGHMEM page for a VMA with caller-specified movable GFP flags</span></span><br><span class="line"><span class="comment"> * @movableflags: The GFP flags related to the pages future ability to move like __GFP_MOVABLE</span></span><br><span class="line"><span class="comment"> * @vma: The VMA the page is to be allocated for</span></span><br><span class="line"><span class="comment"> * @vaddr: The virtual address the page will be inserted into</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function will allocate a page for a VMA but the caller is expected</span></span><br><span class="line"><span class="comment"> * to specify via movableflags whether the page will be movable in the</span></span><br><span class="line"><span class="comment"> * future or not</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * An architecture may override this function by defining</span></span><br><span class="line"><span class="comment"> * __HAVE_ARCH_ALLOC_ZEROED_USER_HIGHPAGE and providing their own</span></span><br><span class="line"><span class="comment"> * implementation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class">__<span class="title">alloc_zeroed_user_highpage</span>(<span class="title">gfp_t</span> <span class="title">movableflags</span>,</span></span><br><span class="line"><span class="class">			<span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>,</span></span><br><span class="line"><span class="class">			<span class="title">unsigned</span> <span class="title">long</span> <span class="title">vaddr</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> alloc_page_vma(GFP_HIGHUSER | movableflags,</span><br><span class="line">			vma, vaddr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (page)</span><br><span class="line">		clear_user_highpage(page, vaddr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<h4 id="alloc-page-vma"><a href="#alloc-page-vma" class="headerlink" title="alloc_page_vma"></a>alloc_page_vma</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> alloc_page_vma(gfp_mask, vma, addr)			\</span></span><br><span class="line"><span class="meta">	alloc_pages_vma(gfp_mask, 0, vma, addr, numa_node_id(), false)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> alloc_pages_vma(gfp_mask, order, vma, addr, node, false)\</span></span><br><span class="line"><span class="meta">	alloc_pages(gfp_mask, order)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> alloc_pages(gfp_mask, order) \</span></span><br><span class="line"><span class="meta">		alloc_pages_node(numa_node_id(), gfp_mask, order)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Allocate pages, preferring the node given as nid. When nid == NUMA_NO_NODE,</span></span><br><span class="line"><span class="comment"> * prefer the current CPU&#x27;s closest node. Otherwise node must be valid and</span></span><br><span class="line"><span class="comment"> * online.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct page *<span class="title">alloc_pages_node</span><span class="params">(<span class="keyword">int</span> nid, <span class="keyword">gfp_t</span> gfp_mask,</span></span></span><br><span class="line"><span class="params"><span class="function">						<span class="keyword">unsigned</span> <span class="keyword">int</span> order)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (nid == NUMA_NO_NODE)</span><br><span class="line">		nid = numa_mem_id();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> __alloc_pages_node(nid, gfp_mask, order);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class">__<span class="title">alloc_pages_node</span>(<span class="title">int</span> <span class="title">nid</span>, <span class="title">gfp_t</span> <span class="title">gfp_mask</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	VM_BUG_ON(nid &lt; <span class="number">0</span> || nid &gt;= MAX_NUMNODES);</span><br><span class="line">	VM_WARN_ON((gfp_mask &amp; __GFP_THISNODE) &amp;&amp; !node_online(nid));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> __alloc_pages(gfp_mask, order, nid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class">__<span class="title">alloc_pages</span>(<span class="title">gfp_t</span> <span class="title">gfp_mask</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>, <span class="title">int</span> <span class="title">preferred_nid</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">return</span> __alloc_pages_nodemask(gfp_mask, order, preferred_nid, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="alloc-pages-nodemask"><a href="#alloc-pages-nodemask" class="headerlink" title="__alloc_pages_nodemask"></a>__alloc_pages_nodemask</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[mm/page_alloc.c]</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is the &#x27;heart&#x27; of the zoned buddy allocator.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class">__<span class="title">alloc_pages_nodemask</span>(<span class="title">gfp_t</span> <span class="title">gfp_mask</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>, <span class="title">int</span> <span class="title">preferred_nid</span>,</span></span><br><span class="line"><span class="class">							<span class="title">nodemask_t</span> *<span class="title">nodemask</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> alloc_flags = ALLOC_WMARK_LOW;</span><br><span class="line">	<span class="keyword">gfp_t</span> alloc_mask; <span class="comment">/* The gfp_t that was actually used for allocation */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">alloc_context</span> <span class="title">ac</span> =</span> &#123; &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * There are several places where we assume that the order value is sane</span></span><br><span class="line"><span class="comment">	 * so bail out early if the request is out of bound.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(order &gt;= MAX_ORDER)) &#123;</span><br><span class="line">		WARN_ON_ONCE(!(gfp_mask &amp; __GFP_NOWARN));</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gfp_mask &amp;= gfp_allowed_mask;</span><br><span class="line">	alloc_mask = gfp_mask;</span><br><span class="line">	<span class="keyword">if</span> (!prepare_alloc_pages(gfp_mask, order, preferred_nid, nodemask, &amp;ac, &amp;alloc_mask, &amp;alloc_flags))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	finalise_ac(gfp_mask, &amp;ac);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Forbid the first pass from falling back to types that fragment</span></span><br><span class="line"><span class="comment">	 * memory until all local zones are considered.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	alloc_flags |= alloc_flags_nofragment(ac.preferred_zoneref-&gt;zone, gfp_mask);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* First allocation attempt */</span></span><br><span class="line">	page = get_page_from_freelist(alloc_mask, order, alloc_flags, &amp;ac);</span><br><span class="line">	<span class="keyword">if</span> (likely(page))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Apply scoped allocation constraints. This is mainly about GFP_NOFS</span></span><br><span class="line"><span class="comment">	 * resp. GFP_NOIO which has to be inherited for all allocation requests</span></span><br><span class="line"><span class="comment">	 * from a particular context which has been marked by</span></span><br><span class="line"><span class="comment">	 * memalloc_no&#123;fs,io&#125;_&#123;save,restore&#125;.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	alloc_mask = current_gfp_context(gfp_mask);</span><br><span class="line">	ac.spread_dirty_pages = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Restore the original nodemask if it was potentially replaced with</span></span><br><span class="line"><span class="comment">	 * &amp;cpuset_current_mems_allowed to optimize the fast-path attempt.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ac.nodemask = nodemask;</span><br><span class="line"></span><br><span class="line">	page = __alloc_pages_slowpath(alloc_mask, order, &amp;ac);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (memcg_kmem_enabled() &amp;&amp; (gfp_mask &amp; __GFP_ACCOUNT) &amp;&amp; page &amp;&amp;</span><br><span class="line">	    unlikely(__memcg_kmem_charge_page(page, gfp_mask, order) != <span class="number">0</span>)) &#123;</span><br><span class="line">		__free_pages(page, order);</span><br><span class="line">		page = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	trace_mm_page_alloc(page, order, alloc_mask, ac.migratetype);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






    </div>

    
    
    

	<div>
      
          <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束 <i class="fa fa-paw"></i> 感谢您的阅读-------------</div>
    
</div>
      
    </div>

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/linux/" rel="tag"># linux</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/11/09/android_binder/" rel="prev" title="从bindService的流程来看Binder框架">
                  <i class="fa fa-chevron-left"></i> 从bindService的流程来看Binder框架
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/01/04/binder_driver/" rel="next" title="Binder驱动概览">
                  Binder驱动概览 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  
  <div class="comments giscus-container">
  </div>
  
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xifengcoder</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">405k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">6:09</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script class="next-config" data-name="giscus" type="application/json">{"enable":true,"repo":"xifengcoder/xifengcoder.github.io","repo_id":"MDEwOlJlcG9zaXRvcnk3MDk3Nzg4Ng==","category":"Announcements","category_id":"DIC_kwDOBDsJXs4Cfd9s","mapping":"pathname","strict":0,"reactions_enabled":1,"emit_metadata":0,"theme":"light","lang":"en","crossorigin":"anonymous","input_position":"bottom","loading":"lazy"}</script>

<script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.page.comments) return;

  NexT.utils.loadComments('.giscus-container')
    .then(() => NexT.utils.getScript('https://giscus.app/client.js', {
      attributes: {
        async                   : true,
        crossOrigin             : 'anonymous',
        'data-repo'             : CONFIG.giscus.repo,
        'data-repo-id'          : CONFIG.giscus.repo_id,
        'data-category'         : CONFIG.giscus.category,
        'data-category-id'      : CONFIG.giscus.category_id,
        'data-mapping'          : CONFIG.giscus.mapping,
        'data-strict'           : CONFIG.giscus.strict,
        'data-reactions-enabled': CONFIG.giscus.reactions_enabled,
        'data-emit-metadata'    : CONFIG.giscus.emit_metadata,
        'data-theme'            : CONFIG.giscus.theme,
        'data-lang'             : CONFIG.giscus.lang,
        'data-input-position'   : CONFIG.giscus.input_position,
        'data-loading'          : CONFIG.giscus.loading
      },
      parentNode: document.querySelector('.giscus-container')
    }));
});
</script>

</body>
</html>
